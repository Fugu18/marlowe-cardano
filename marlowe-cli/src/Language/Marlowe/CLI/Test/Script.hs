-----------------------------------------------------------------------------
--
-- Module      :  $Headers
-- License     :  Apache 2.0
--
-- Stability   :  Experimental
-- Portability :  Portable
--
-- | Testing Marlowe contracts without the PAB.
--
-----------------------------------------------------------------------------


{-# LANGUAGE BlockArguments #-}
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE GADTs #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE NumericUnderscores #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TupleSections #-}


module Language.Marlowe.CLI.Test.Script
  where

-- import Cardano.Api
--   ( AsType(AsPaymentKey)
--   , CardanoMode
--   , IsShelleyBasedEra
--   , Key(getVerificationKey, verificationKeyHash)
--   , LocalNodeConnectInfo(..)
--   , PaymentCredential(PaymentCredentialByKey)
--   , ScriptDataSupportedInEra
--   , StakeAddressReference(NoStakeAddress)
--   , generateSigningKey
--   , makeShelleyAddressInEra, Lovelace (Lovelace)
--   )
-- import Control.Monad (foldM, forM, forM_, void, when, unless)
-- import Control.Monad.Except (MonadError, MonadIO, catchError, liftIO, throwError, runExceptT, ExceptT)
-- import Control.Monad.State.Strict (MonadState, execStateT)
-- import Language.Marlowe.CLI.Command.Template (initialMarloweState, makeContract)
-- import Language.Marlowe.CLI.Types
--   ( AnUTxO(AnUTxO)
--   , CliEnv(..)
--   , CliError(..)
--   , CoinSelectionStrategy(CoinSelectionStrategy)
--   , CurrencyIssuer(CurrencyIssuer)
--   , MarlowePlutusVersion
--   , MarloweScriptsRefs(MarloweScriptsRefs)
--   , MarloweTransaction(mtState)
--   , OutputQueryResult
--   , PrintStats(PrintStats)
--   , PublishingStrategy(PublishAtAddress, PublishPermanently)
--   , ValidatorInfo(ValidatorInfo)
--   , defaultCoinSelectionStrategy
--   , toMarloweTimeout
--   , toPOSIXTime
--   , unAnUTxO, SubmitMode (DoSubmit, DontSubmit), Seconds (Seconds)
--   )
--
-- import Language.Marlowe.Extended.V1 as E (ChoiceId(ChoiceId), Contract(Close), Party, Value(Constant))
-- import Marlowe.Contracts (escrow, swap, trivial)
-- import Plutus.V1.Ledger.Api (CostModelParams, TokenName)
--
-- import qualified Cardano.Api as C
-- import Control.Lens (assign, modifying, use, view)
-- import Control.Monad.Extra (whenM)
-- import Control.Monad.RWS.Class (MonadReader)
-- import Control.Monad.Reader (ReaderT(runReaderT))
-- import qualified Data.Aeson as A
-- import qualified Data.Aeson.KeyMap as KeyMap
-- import qualified Data.Aeson.OneLine as A
-- import qualified Data.Fixed as F
-- import Data.Foldable (Foldable(fold), foldl', find)
-- import Data.Foldable.Extra (for_)
-- import Data.Functor ((<&>))
-- import Data.List.NonEmpty (NonEmpty((:|)), (<|))
-- import qualified Data.List.NonEmpty as L.NonEmpty
-- import qualified Data.List.NonEmpty as NE
-- import qualified Data.Map.Strict as Map
-- import Data.Maybe (fromMaybe, isJust, mapMaybe)
-- import qualified Data.Set as S (singleton)
-- import qualified Data.Text as Text
-- import Data.Traversable (for)
-- import Data.Tuple.Extra (uncurry3)
-- import Language.Marlowe.CLI.Cardano.Api.PlutusScript (IsPlutusScriptLanguage)
-- import Language.Marlowe.CLI.Cardano.Api.Value (txOutValueValue)
-- import qualified Language.Marlowe.CLI.Cardano.Api.Value as CV
-- import qualified Language.Marlowe.CLI.Data.Aeson.Traversals as A
-- import Language.Marlowe.CLI.IO (liftCliMaybe, queryInEra)
-- import Language.Marlowe.CLI.Run
--   ( autoRunTransactionImpl
--   , autoWithdrawFundsImpl
--   , initializeTransactionImpl
--   , initializeTransactionUsingScriptRefsImpl
--   , marloweAddressFromCardanoAddress
--   , marloweAddressToCardanoAddress
--   , prepareTransactionImpl
--   )
-- import Language.Marlowe.CLI.Sync (classifyOutputs, isMarloweOut)
-- import Language.Marlowe.CLI.Sync.Types (MarloweOut(ApplicationOut, moTxIn))
-- import Language.Marlowe.CLI.Test.Script.Debug
--   (SoFormat(SoName), logSoMsg, logSoMsg', logTraceMsg, runSoCli, throwSoError, withCliErrorMsg, throwTraceError)
-- import Language.Marlowe.CLI.Test.Types
--   ( AssetId(AdaAsset, AssetId)
--   , Assets(Assets)
--   , ContractNickname
--   , ContractSource(..)
--   , Currency(Currency, ccCurrencySymbol, ccIssuer)
--   , CurrencyNickname(..)
--   , ExecutionMode(..)
--   , MarloweContract(..)
--   , PartyRef(RoleRef, WalletRef)
--   , ScriptEnv(..)
--   , ScriptOperation(..)
--   , ScriptState
--   , ScriptTest(ScriptTest, stScriptOperations, stTestName)
--   , TokenAssignment(TokenAssignment)
--   , UseTemplate(..)
--   , Wallet(..)
--   , WalletNickname(WalletNickname)
--   , anyCLIMarloweThread
--   , emptyWallet
--   , faucetNickname
--   , foldrMarloweThread
--   , getCLIMarloweThreadTransaction
--   , getCLIMarloweThreadTxBody
--   , getMarloweThreadTxIn
--   , overAnyMarloweThread
--   , scriptState
--   , seConnection
--   , seCostModelParams
--   , seEra
--   , seEventBackend
--   , seExecutionMode
--   , sePrintStats
--   , seProtocolVersion
--   , seSlotConfig
--   , ssContracts
--   , ssCurrencies
--   , ssReferenceScripts
--   , ssWallets
--   -- , ssRuntimeContractStreams
--   , marloweThreadContractId
--   , RuntimeError (..), anyRuntimeMarloweThread, MarloweThread (Created, Closed), AnyMarloweThread, anyMarloweThreadCreated, RuntimeMarloweThread, AnyRuntimeMarloweThread
--   )
-- import Language.Marlowe.CLI.Transaction
--   (buildFaucetImpl, buildMintingImpl, findMarloweScriptsRefs, publishImpl, selectUtxosImpl)
-- import qualified Language.Marlowe.CLI.Types as T
-- import qualified Language.Marlowe.Client as Client
-- import qualified Language.Marlowe.Core.V1.Semantics as M
-- import qualified Language.Marlowe.Core.V1.Semantics.Types as M
-- import Language.Marlowe.Pretty (pretty)
-- import Ledger.Tx.CardanoAPI (fromCardanoPolicyId)
-- import Plutus.ApiCommon (ProtocolVersion)
-- import Plutus.V1.Ledger.SlotConfig (SlotConfig(..))
-- import Plutus.V1.Ledger.Value (mpsSymbol, valueOf)
-- import qualified Plutus.V1.Ledger.Value as P
-- import qualified Plutus.V1.Ledger.Value as Value
-- import PlutusPrelude (foldMapM)
-- import PlutusTx.Prelude (inv)
-- import qualified PlutusTx.Prelude as PTx
-- import System.IO.Temp (emptySystemTempFile, emptyTempFile)
-- import Observe.Event.Render.JSON (defaultRenderSelectorJSON)
-- import Observe.Event.Render.JSON.Handle (simpleJsonStderrBackend)
-- import Control.Concurrent.STM (newTChanIO, readTChan, atomically, newTVarIO, writeTChan, writeTVar, TVar, modifyTVar')
-- import Language.Marlowe.Runtime.App.Stream (streamAllContractSteps, ContractStream (..), ContractStreamError(..))
-- import Language.Marlowe.Runtime.App.Types (runClient)
-- import Control.Concurrent (forkFinally)
-- import qualified Language.Marlowe.Runtime.App.Run as Apps
-- import qualified Language.Marlowe.Runtime.App.Run as Apps.Run
-- import Data.Default (Default(def))
-- import qualified Data.Map.Strict as M
-- import Control.Category ((>>>))
-- import Control.Lens.Setter ((%=))
-- import Control.Exception (Exception(displayException))
-- import qualified Language.Marlowe.Runtime.App.Types as Apps
-- import qualified Language.Marlowe.Runtime.Cardano.Api as Runtime.Cardano.Api
-- import qualified Language.Marlowe.Runtime.Core.Api as Runtime.Core.Api
-- import qualified Language.Marlowe.Runtime.Core.Api as R
-- import qualified Language.Marlowe.Runtime.History.Api as RH
-- import Control.Concurrent.STM.TVar (readTVar)
-- import Control.Concurrent.Async (async, cancel, waitCatch, concurrently, race)
-- import Control.Monad.Loops (untilJust)
-- import Language.Marlowe.Runtime.App.Channel (mkDetection)
-- import Control.Monad.Trans (MonadTrans(lift))
-- import Language.Marlowe.Runtime.Core.Api (ContractId(ContractId))
-- import Control.Monad.STM (STM)
--
-- transactionSubmitMode :: MonadError CliError m
--           => MonadReader (ScriptEnv era) m
--           => m SubmitMode
-- transactionSubmitMode = do
--   view seExecutionMode >>= \case
--     (OnChainMode timeout) -> pure $ DoSubmit timeout
--     SimulationMode -> pure DontSubmit
--
-- -- getOrCreateRuntimeContractStream nickname = do
-- --   use ssRuntimeContractStreams >>= \channels -> case M.lookup nickname channels of
-- --     Just chan -> pure chan
-- --     Nothing -> use ssContracts >>= \contracts -> case M.lookup nickname contracts of
-- --       Nothing ->
-- --         throwTraceError "getOrCreateRuntimeStream" $ "Contract not found for nickname " <> show nickname
-- --       Just MarloweContract { mcThread = Nothing } ->
-- --         throwTraceError "getOrCreateRuntimeStream" $ "Unable to await contract for nickname " <> show nickname <> " because it is not running."
-- --       Just MarloweContract { mcThread = Just thread } -> do
-- --         let
-- --           contractId = overAnyMarloweThread marloweThreadContractId thread
-- --         chan <- runRuntimeSyncClient contractId
-- --         ssRuntimeContractStreams %= M.insert nickname chan
-- --         pure chan
-- --
-- -- awaitContractStream nickname = do
-- --   chan <- getOrCreateRuntimeContractStream nickname
-- --   liftIO $ atomically $ readTChan chan
-- --
-- interpret :: forall era m
--            . IsShelleyBasedEra era
--           => MonadError CliError m
--           => MonadState (ScriptState MarlowePlutusVersion era) m
--           => MonadReader (ScriptEnv era) m
--           => MonadIO m
--           => ScriptOperation
--           -> m ()
-- interpret so@RuntimeAwaitCreated {..} = do
--   pure ()
-- --  view seExecutionMode >>= \case
-- --    SimulationMode -> do
-- --      logSoMsg' so "[Skip] Skipping runtime check in the simulation mode."
-- --      pure ()
-- --    OnChainMode {} -> do
-- --      stream <- awaitContractStream soContractNickname
-- --      case stream of
-- --        ContractStreamStart {} -> pure ()
-- --        ContractStreamFinish _ (Just _) ->
-- --          -- retry
-- --          interpret so
-- --        _ -> throwSoError so $ "Expecting contract stream start but got: " <> show stream
-- interpret so@RuntimeAwaitInputsApplied {..} = do
--   pure ()
-- --   view seExecutionMode >>= \case
-- --     SimulationMode -> do
-- --       logSoMsg' so "[Skip] Skipping runtime check in the simulation mode."
-- --       pure ()
-- --     OnChainMode {} -> do
-- --       stream <- awaitContractStream soContractNickname
-- --       case stream of
-- --         ContractStreamContinued {..} -> pure ()
-- --         _ -> throwSoError so $ "Expecting contract stream continued but got: " <> show stream
-- interpret so@RuntimeAwaitClosed {..} = do
--   pure ()
-- --   view seExecutionMode >>= \case
-- --     SimulationMode -> do
-- --       logSoMsg' so "[Skip] Skipping runtime check in the simulation mode."
-- --       pure ()
-- --     OnChainMode {} -> do
-- --       stream <- awaitContractStream soContractNickname
-- --       case stream of
-- --         ContractStreamFinish {..} -> pure ()
-- --         _ -> throwSoError so $ "Expecting contract stream finished but got: " <> show stream
-- interpret SplitWallet {..} = do
--   Wallet address _ _ skey _ <- findWallet soWalletNickname
--   connection <- view seConnection
--   submitMode <- transactionSubmitMode
--   let
--     values = [ C.lovelaceToValue v | v <- soValues ]
--
--   void $ runCli "[createCollaterals] " $ buildFaucetImpl
--     connection
--     (Just values)
--     [address]
--     address
--     skey
--     defaultCoinSelectionStrategy
--     submitMode
--
-- interpret so@Mint {..} = do
--   let
--     issuerNickname = fromMaybe faucetNickname soIssuer
--
--   currencies <- use ssCurrencies
--   case Map.lookup soCurrencyNickname currencies of
--     Just Currency { ccIssuer=ci } -> when (ci /= issuerNickname)  do
--       throwError "Currency with a given nickname already exist and is minted by someone else."
--     Nothing -> pure ()
--
--   Wallet issuerAddress _ _ issuerSigningKey _ <- findWallet issuerNickname
--   (tokenDistribution, walletAssignemnts) <- unzip <$> forM soTokenDistribution \(TokenAssignment owner tokenName amount) -> do
--     Wallet destAddress _ _ _ _ <- findWallet owner
--     pure ((tokenName, amount, destAddress, Just soMinLovelace), (owner, tokenName, amount))
--
--   logSoMsg' so $ "Minting currency " <> show soCurrencyNickname <> " with tokens distribution: " <> show soTokenDistribution
--   tokenDistribution' <- maybe (throwSoError so "Token distribution shouldn't be empty") pure $ L.NonEmpty.nonEmpty tokenDistribution
--   let
--     mintingAction = T.Mint
--       (CurrencyIssuer issuerAddress issuerSigningKey)
--       tokenDistribution'
--
--   connection <- view seConnection
--   submitMode <- transactionSubmitMode
--   printStats <- view sePrintStats
--   (mintingTx, policy) <- runCli "[Mint] " $ buildMintingImpl
--     connection
--     mintingAction
--     soMetadata
--     Nothing
--     submitMode
--     printStats
--
--   logSoMsg' so $ "This currency symbol is " <> show policy
--   let
--     currencySymbol = mpsSymbol . fromCardanoPolicyId $ policy
--     currency = Currency currencySymbol issuerNickname policy
--     C.TxBody mintingTxContent = mintingTx
--
--   forM_ walletAssignemnts \(walletNickname, tokenName, amount) -> do
--     updateWallet walletNickname \wallet@Wallet {..} ->  do
--       let
--         tokenValue = Value.singleton currencySymbol tokenName (toInteger amount)
--       wallet
--         { waMintedTokens = tokenValue <> waMintedTokens
--         }
--
--   updateWallet issuerNickname \issuer@Wallet {..} -> do
--     let
--       C.TxBody c = mintingTx
--       minAdas = C.txOuts c `foldMapFlipped` \(C.TxOut addr value _ _) ->
--         if addr /= issuerAddress
--           then lovelaceToPlutusValue . C.selectLovelace . C.txOutValueToValue $ value
--           else mempty
--     issuer
--       { waSubmittedTransactions = mintingTx : waSubmittedTransactions
--       }
--   ssCurrencies `modifying` Map.insert soCurrencyNickname currency
--
--
-- interpret so@Initialize {..} = do
--   let
--     log' = logSoMsg SoName so
--
--   marloweContract <- case soContractSource of
--     InlineContract json -> decodeContractJSON json
--     UseTemplate setup   -> useTemplate soRoleCurrency setup
--
--   log' $ "Contract: " <> show (pretty marloweContract)
--
--   let
--     submitterNickname = fromMaybe faucetNickname soSubmitter
--   address <- waAddress <$> findWallet submitterNickname
--   submitterParty <- uncurry M.Address <$> marloweAddressFromCardanoAddress address
--
--   currencySymbol <- case soRoleCurrency of
--     Nothing -> pure P.adaSymbol
--     Just nickname -> do
--       Currency { ccCurrencySymbol } <- findCurrency nickname
--       pure ccCurrencySymbol
--
--   let
--     Lovelace minAda = soMinLovelace
--     marloweState = initialMarloweState submitterParty minAda
--     marloweParams = Client.marloweParams currencySymbol
--
--   slotConfig <- view seSlotConfig
--   costModelParams <- view seCostModelParams
--   protocolVersion <- view seProtocolVersion
--   LocalNodeConnectInfo { localNodeNetworkId } <- view seConnection
--   marloweTransaction <- use ssReferenceScripts >>= \case
--     Just refs -> do
--       logSoMsg' so "Using reference scripts to initialize Marlowe contract."
--       runSoCli so $ initializeTransactionUsingScriptRefsImpl
--         marloweParams
--         slotConfig
--         refs
--         NoStakeAddress
--         marloweContract
--         marloweState
--         False
--         True
--     Nothing -> do
--       logSoMsg' so "Using in Tx scripts strategy to initialize Marlowe contract."
--       runSoCli so $ initializeTransactionImpl
--         marloweParams
--         slotConfig
--         protocolVersion
--         costModelParams
--         localNodeNetworkId
--         NoStakeAddress
--         marloweContract
--         marloweState
--         Nothing
--         False
--         True
--
--   whenM (isJust . Map.lookup soContractNickname <$> use ssContracts) do
--     throwError "[Initialize] Contract with a given nickname already exist."
--
--   modifying ssContracts $ Map.insert soContractNickname $ MarloweContract
--     {
--       mcContract = marloweContract
--     , mcPlan = marloweTransaction :| []
--     , mcThread = Nothing
--     , mcWithdrawalsCheckPoints = mempty
--     , mcCurrency = soRoleCurrency
--     , mcSubmitter = submitterNickname
--     }
--
-- interpret Prepare {..} = do
--   marloweContract@MarloweContract {..} <- findMarloweContract soContractNickname
--
--   let
--     curr = NE.head mcPlan
--   inputs <- for soInputs \input -> decodeInputJSON input
--   minimumTime <- toPOSIXTime soMinimumTime
--   maximumTime <- toPOSIXTime soMaximumTime
--   new <- runCli "[Prepare] " $ prepareTransactionImpl
--     curr
--     inputs
--     minimumTime
--     maximumTime
--     True
--
--   let
--     new' = case soOverrideMarloweState of
--       Just customState -> new { mtState = customState }
--       Nothing          -> new
--     plan = new' <| mcPlan
--     marloweContract' = marloweContract{ mcPlan = plan }
--
--   modifying ssContracts $ Map.insert soContractNickname marloweContract'
--
-- interpret so@AutoRun {..} = do
--   view seExecutionMode >>= \case
--     SimulationMode -> logSoMsg' so "[Skip] Skipping transaction submission to the chain in the simulation mode."
--     OnChainMode _ -> do
--       marloweContract@MarloweContract {..} <- findMarloweContract soContractNickname
--       let
--         plan = do
--           let
--             whole = reverse $ NE.toList mcPlan
--             threadLength = foldrMarloweThread (const (+ 1)) 0
--           case mcThread of
--             Just thread -> do
--               let
--                 l = overAnyMarloweThread threadLength thread
--               drop l whole
--             Nothing -> whole
--         step mTh mt = do
--           let
--             prev :: Maybe (MarloweTransaction MarlowePlutusVersion era, C.TxIn)
--             prev = do
--               pmt <- overAnyMarloweThread getCLIMarloweThreadTransaction <$> mTh
--               txIn <- overAnyMarloweThread getMarloweThreadTxIn =<< mTh
--               pure (pmt, txIn)
--             invalid = fromMaybe False soInvalid
--
--           (txBody, mTxIn) <- autoRunTransaction mcCurrency mcSubmitter prev mt invalid
--           case (mTh, mTxIn) of
--             (Nothing, Nothing) -> throwError "[AutoRun] Creation of the Marlowe thread failed."
--             (Nothing, Just txIn) -> pure $ Just $ anyMarloweThreadCreated (mt, txBody) txIn
--             (Just th, _) -> case anyCLIMarloweThread (mt, txBody) mTxIn th of
--               Just th' -> pure $ Just th'
--               Nothing  -> throwError "[AutoRun] Extending of the Marlowe thread failed."
--
--       thread' <- foldM step mcThread plan
--       let
--         marloweContract' = marloweContract { mcThread = thread' }
--       ssContracts `modifying`  Map.insert soContractNickname marloweContract'
--
-- interpret so@Withdraw {..} = do
--   view seExecutionMode >>= \case
--     SimulationMode -> logSoMsg' so "[Skip] Withdrawals are not submitted to chain in the simulation mode."
--     OnChainMode _ -> do
--       marloweContract@MarloweContract {..} <- findMarloweContract soContractNickname
--
--       marloweThread <- case mcThread of
--         Just marloweThread -> pure marloweThread
--         Nothing -> throwSoError so "Contract is not on the chain yet so there are not payouts as well."
--       Wallet{waAddress, waSigningKey, waMintedTokens} <- findWallet soWalletNickname
--       Currency { ccCurrencySymbol } <- maybe (snd <$> getCurrency) findCurrency mcCurrency
--       let
--         roles = P.flattenValue waMintedTokens `foldMapFlipped` \(cs, tn, _) ->
--           if cs == ccCurrencySymbol
--             then [tn]
--             else mempty
--       when (roles == mempty) $ do
--         throwSoError so $ fold
--           [ "Provided wallet "
--           , show soWalletNickname
--           , "has no roles associated with the given contract "
--           , show soContractNickname
--           ]
--
--       submitMode <- transactionSubmitMode
--       connection <- view seConnection
--       txBodies <- foldMapMFlipped roles \role -> do
--         let
--           lastWithdrawalCheckPoint = Map.lookup role mcWithdrawalsCheckPoints
--           threadTransactions :: [(MarloweTransaction MarlowePlutusVersion era, C.TxId)]
--           threadTransactions = do
--             let step item acc = (getCLIMarloweThreadTransaction item, C.getTxId . getCLIMarloweThreadTxBody $ item) : acc
--             overAnyMarloweThread (foldrMarloweThread step []) marloweThread
--
--           possibleWithdrawals = takeWhile ((/=) lastWithdrawalCheckPoint . Just . snd) threadTransactions
--
--           paymentRole (M.Payment _ (M.Party (M.Role r)) _ _) = Just r
--           paymentRole _ = Nothing
--
--           -- Sometimes we reuse the same currency across multiple tests (when Faucet is an issuer) so we
--           -- need to filter out payouts which are really associated with this particular test
--           -- case. We can identify them by matching them against a set of submitted transaction ids.
--           filterPayoutsUTxOs utxos = do
--             let
--               txIds = map snd possibleWithdrawals
--               txInId (C.TxIn txId _) = txId
--             filter (flip elem txIds . txInId . fst . unAnUTxO) utxos
--
--         let
--           anyWithdrawalsExist = possibleWithdrawals `anyFlipped` \(T.MarloweTransaction{..}, _) -> do
--             elem role . mapMaybe paymentRole $ mtPayments
--
--         if anyWithdrawalsExist
--           then do
--             let
--               roleToken = M.Token ccCurrencySymbol role
--               T.MarloweTransaction { mtRoleValidator } :| _ = mcPlan
--
--             logSoMsg' so $ "Withdrawing funds for role " <> show role <> " after application of inputs: " <> do
--               let
--                 inputs = foldMapFlipped possibleWithdrawals \(T.MarloweTransaction { mtInputs }, _) -> mtInputs
--               show inputs
--
--             txBody <- runSoCli so $ autoWithdrawFundsImpl
--               connection
--               roleToken
--               mtRoleValidator
--               Nothing
--               waAddress
--               [waSigningKey]
--               (Just filterPayoutsUTxOs)
--               C.TxMetadataNone
--               submitMode
--               (PrintStats True)
--               False
--             pure [txBody]
--           else
--             pure []
--
--       updateWallet soWalletNickname \wallet@Wallet {waSubmittedTransactions} ->
--         wallet { waSubmittedTransactions = txBodies <> waSubmittedTransactions }
--
--       let
--         newWithdrawals = foldMapFlipped roles \role ->
--           Map.singleton role (C.getTxId . overAnyMarloweThread getCLIMarloweThreadTxBody $ marloweThread)
--         marloweContract' = marloweContract{ mcWithdrawalsCheckPoints = newWithdrawals <> mcWithdrawalsCheckPoints }
--       modifying ssContracts $ Map.insert soContractNickname marloweContract'
--
-- interpret so@Publish {..} = do
--   whenM (isJust <$> use ssReferenceScripts) do
--     throwSoError so "Scripts already published in this test script."
--
--   Wallet { waAddress, waSigningKey } <- maybe getFaucet findWallet soPublisher
--   let
--     publishingStrategy = case soPublishPermanently of
--       Just True -> PublishPermanently NoStakeAddress
--       _         -> PublishAtAddress waAddress
--
--   connection <- view seConnection
--   printStats <- view sePrintStats
--   marloweScriptRefs <- runSoCli so (findMarloweScriptsRefs connection publishingStrategy printStats) >>= \case
--     Just marloweScriptRefs@(MarloweScriptsRefs (AnUTxO (mTxIn, _), mv) (AnUTxO (pTxIn, _), pv)) -> do
--       let
--         logValidatorInfo ValidatorInfo {..} = do
--           logSoMsg' so $ Text.unpack (C.serialiseAddress viAddress)
--
--       logSoMsg' so "Found already published scripts so using them."
--       logSoMsg' so $ "Marlowe reference: " <> show mTxIn
--       logValidatorInfo mv
--       logSoMsg' so $ "Payout reference: " <> show pTxIn
--       logValidatorInfo pv
--       pure marloweScriptRefs
--
--     Nothing -> view seExecutionMode >>= \case
--       SimulationMode -> throwSoError so "Can't perform on chain script publishing in simulation mode"
--       OnChainMode (Seconds timeout) -> do
--         logSoMsg' so "Scripts not found so publishing them."
--         runSoCli so $ publishImpl
--           connection
--           waSigningKey
--           Nothing
--           waAddress
--           publishingStrategy
--           (CoinSelectionStrategy False False [])
--           timeout
--           (PrintStats True)
--   assign ssReferenceScripts (Just marloweScriptRefs)
--
-- interpret (Fail message) = throwError $ CliError message
--
--
-- autoRunTransaction :: forall era lang m
--                     . IsShelleyBasedEra era
--                    => IsPlutusScriptLanguage lang
--                    => MonadError CliError m
--                    => MonadReader (ScriptEnv era) m
--                    => MonadState (ScriptState lang era) m
--                    => MonadIO m
--                    => Maybe CurrencyNickname
--                    -> WalletNickname
--                    -> Maybe (MarloweTransaction lang era, C.TxIn)
--                    -> MarloweTransaction lang era
--                    -> Bool
--                    -> m (C.TxBody era, Maybe C.TxIn)
-- autoRunTransaction currency defaultSubmitter prev curr@T.MarloweTransaction {..} invalid = do
--   let
--     log' = logTraceMsg "autoRunTransaction"
--
--     getNormalInputParty = \case
--       M.IDeposit _ party _ _         -> Just party
--       M.IChoice (ChoiceId _ party) _ -> Just party
--       M.INotify                      -> Nothing
--
--     getInputParty :: Maybe Party -> M.Input -> m (Maybe Party)
--     getInputParty Nothing (M.NormalInput input) = pure $ getNormalInputParty input
--     getInputParty reqParty (M.NormalInput input) = case getNormalInputParty input of
--       Nothing -> pure reqParty
--       reqParty' | reqParty /= reqParty' ->
--         throwError . CliError $
--           "[autoRunTransaction] can handle only inputs which can be executed by a single party: " <> show reqParty <> " /= " <> show reqParty'
--       _ -> pure reqParty
--     getInputParty _ M.MerkleizedInput {} =
--       throwError "[autoRunTransaction] merkleized input handling is not implemented yet."
--
--   log' $ "Applying marlowe inputs: " <> show mtInputs
--   log' $ "Output contract: " <> show (pretty mtContract)
--   log' $ "Output state: " <> show mtState
--
--   (submitterNickname, Wallet address _ _ skey _) <- foldM getInputParty Nothing mtInputs >>= \case
--     Nothing                          -> (defaultSubmitter,) <$> findWallet defaultSubmitter
--     Just (M.Address network address) -> (findWalletByAddress =<< marloweAddressToCardanoAddress network address)
--     Just (M.Role rn)                 -> case currency of
--       Just cn -> findWalletByUniqueToken cn rn
--       Nothing -> throwError "[autoRunTransaction] Contract requires a role currency which was not specified."
--
--   connection <- view seConnection
--   submitMode <- transactionSubmitMode
--   txBody <- runCli "[AutoRun] " $ autoRunTransactionImpl
--       connection
--       prev
--       curr
--       address
--       [skey]
--       C.TxMetadataNone
--       submitMode
--       True
--       invalid
--
--   log' $ "TxBody:" <> show txBody
--   let
--     C.TxBody C.TxBodyContent{..} = txBody
--     mTxId = C.getTxId txBody
--
--   log' $ "TxId:" <> show mTxId
--
--   updateWallet submitterNickname \submitter@Wallet {..} ->
--     submitter { waSubmittedTransactions = txBody : waSubmittedTransactions }
--
--   NEW VERSION:
--   let meOuts = classifyOutputs mTxId txOuts
--   case filter isMarloweOut meOuts of
--     [ApplicationOut {moTxIn}] -> do
--       log' $ "Marlowe output:" <> show moTxIn
--       pure (txBody, Just moTxIn)
--     []                        -> pure (txBody, Nothing)
--     _                         -> throwError "[AutoRun] Multiple Marlowe outputs detected - unable to handle them yet."
-- 
--
--   case classifyOutputs mTxId txOuts of
--     Right meOuts -> case filter isMarloweOut meOuts of
--       [ApplicationOut {moTxIn}] -> do
--         log' $ "Marlowe output:" <> show moTxIn
--         pure (txBody, Just moTxIn)
--       []                        -> pure (txBody, Nothing)
--       _                         -> throwError "[AutoRun] Multiple Marlowe outputs detected - unable to handle them yet."
--     Left e -> throwError . CliError $ "[AutoRun] Marlowe output anomaly: " <> show e
--
--
-- findMarloweContract :: MonadError CliError m
--                     => MonadState (ScriptState lang era) m
--                     => ContractNickname   -- ^ The nickname.
--                     -> m (MarloweContract lang era)
-- findMarloweContract nickname = do
--   contracts <- use ssContracts
--   liftCliMaybe
--     ("[findMarloweContract] Marlowe contract structure was not found for a given nickname " <> show nickname <> ".")
--     $ Map.lookup nickname contracts
--
--
-- useTemplate :: MonadError CliError m
--             => MonadState (ScriptState lang era) m
--             => MonadIO m
--             => Maybe CurrencyNickname
--             -> UseTemplate
--             -> m M.Contract
-- useTemplate currency = do
--   \case
--     UseTrivial{..} -> do
--       timeout' <- toMarloweTimeout utTimeout
--       let
--         partyRef = fromMaybe (WalletRef "faucet") utParty
--       party <- buildParty currency partyRef
--       makeContract $ trivial
--         party
--         utDepositLovelace
--         utWithdrawalLovelace
--         timeout'
--     UseSwap{..} -> do
--       aTimeout' <- toMarloweTimeout utATimeout
--       bTimeout' <- toMarloweTimeout utBTimeout
--       Currency { ccCurrencySymbol=aCurrencySymbol } <- findCurrency utACurrencyNickname
--       Currency { ccCurrencySymbol=bCurrencySymbol } <- findCurrency utBCurrencyNickname
--       let
--         aPartyRef = fromMaybe (WalletRef "aParty") utAParty
--         bPartyRef = fromMaybe (WalletRef "bParty") utBParty
--       aParty <- buildParty currency aPartyRef
--       bParty <- buildParty currency bPartyRef
--       makeContract $ swap
--           aParty
--           (M.Token aCurrencySymbol utATokenName)
--           (Constant utAAmount)
--           aTimeout'
--           bParty
--           (M.Token bCurrencySymbol utBTokenName)
--           (Constant utBAmount)
--           bTimeout'
--           Close
--     UseEscrow{..} -> do
--       paymentDeadline' <- toMarloweTimeout utPaymentDeadline
--       complaintDeadline' <- toMarloweTimeout utComplaintDeadline
--       disputeDeadline' <- toMarloweTimeout utDisputeDeadline
--       mediationDeadline' <- toMarloweTimeout utMediationDeadline
--       let
--         sellerRef = fromMaybe (WalletRef "seller") utSeller
--         buyerRef = fromMaybe (WalletRef "buyer") utBuyer
--         mediatorRef = fromMaybe (WalletRef "mediator") utMediator
--       seller <- buildParty currency sellerRef
--       buyer <- buildParty currency buyerRef
--       mediator <- buildParty currency mediatorRef
--
--       makeContract $ escrow
--         (Constant utPrice)
--         seller
--         buyer
--         mediator
--         paymentDeadline'
--         complaintDeadline'
--         disputeDeadline'
--         mediationDeadline'
--     --UseZeroCouponBond{..} -> do  lendingDeadline' <- toMarloweTimeout lendingDeadline
--     --                             paybackDeadline' <- toMarloweTimeout paybackDeadline
--     --                             makeContract $
--     --                               zeroCouponBond
--     --                                 lender
--     --                                 borrower
--     --                                 lendingDeadline'
--     --                                 paybackDeadline'
--     --                                 (Constant principal)
--     --                                 (Constant principal `AddValue` Constant interest)
--     --                                 ada
--     --                                 Close
--     --UseCoveredCall{..} -> do issueDate' <- toMarloweTimeout issueDate
--     --                         maturityDate' <- toMarloweTimeout maturityDate
--     --                         settlementDate' <- toMarloweTimeout settlementDate
--     --                         makeContract $ coveredCall
--     --                             issuer
--     --                             counterparty
--     --                             Nothing
--     --                             currency
--     --                             underlying
--     --                             (Constant strike)
--     --                             (Constant amount)
--     --                             issueDate'
--     --                             maturityDate'
--     --                             settlementDate'
--     template -> throwError $ CliError $ "Template not implemented: " <> show template
--
--
-- buildParty :: MonadState (ScriptState lang era) m
--            => MonadError CliError m
--            => Maybe CurrencyNickname
--            -> PartyRef
--            -> m Party
-- buildParty currencyNickname = \case
--   WalletRef nickname -> do
--       wallet <- findWallet nickname
--       uncurry M.Address <$> marloweAddressFromCardanoAddress (waAddress wallet)
--   RoleRef token -> do
--     -- Cosistency check
--     currency <- case currencyNickname of
--       Nothing -> fst <$> getCurrency
--       Just cn -> pure cn
--     void $ findWalletByUniqueToken currency token
--     -- We are allowed to use this M.Role
--     pure $ M.Role token
--
--
-- findWallet :: MonadError CliError m
--            => MonadState (ScriptState lang era) m
--            => WalletNickname
--            -> m (Wallet era)
-- findWallet nickname = do
--   wallets <- use ssWallets
--   liftCliMaybe ("[findWallet] Unable to find wallet:" <> show nickname) $ Map.lookup nickname wallets
--
-- data TestResult = TestPassed | TestFailed
--
-- data TestRunnerResult
--   = TestFinished TestResult
--   | RuntimeFailure RuntimeError
--
-- -- | Test a Marlowe contract.
-- scriptTest  :: forall era m
--              . MonadError CliError m
--             => IsShelleyBasedEra era
--             => MonadIO m
--             => ScriptDataSupportedInEra era
--             -> ProtocolVersion
--             -> CostModelParams
--             -> LocalNodeConnectInfo CardanoMode  -- ^ The connection to the local node.
--             -> Wallet era                        -- ^ Wallet which should be used as faucet.
--             -> SlotConfig                        -- ^ The time and slot correspondence.
--             -> ExecutionMode
--             -> ScriptTest                        -- ^ The tests to be run.
--             -> m ()                              -- ^ Action for running the tests.
-- scriptTest era protocolVersion costModel connection faucet slotConfig executionMode ScriptTest{..} =
--   do
--     liftIO $ putStrLn ""
--     liftIO . putStrLn $ "***** Test " <> show stTestName <> " *****"
--     eventBackend <- liftIO $ simpleJsonStderrBackend defaultRenderSelectorJSON
--     let
--       printStats = PrintStats True
--       scriptEnv = ScriptEnv connection costModel era protocolVersion slotConfig executionMode printStats eventBackend
--     runScriptTest scriptEnv (scriptState faucet) stScriptOperations
--
--
--
--
-- --  -- let
-- --  --   runtimeSetup = def
-- --  --     { -- chainSeekHost = "127.0.0.1"
-- --  --       Apps.chainSeekSyncPort = 33584 -- 3715
-- --  --     , Apps.chainSeekCommandPort = 33582 -- 3720
-- --  --     , Apps.runtimePort = 33589 -- 3700
-- --  --     -- , Apps.runtimeHost = "127.0.0.1"
-- --  --     -- , timeoutSeconds = 900
-- --  --     -- , buildSeconds = 3
-- --  --     -- , confirmSeconds = 3
-- --  --     -- , retrySeconds = 10
-- --  --     -- , retryLimit = 5
-- --  --     }
-- --  discoveryChannel <- newTChanIO
--
--
--
--
--   --runRuntimeSyncClient contractId = do
--   --  contractChan <- liftIO newTChanIO
--   --  let
--   --    pollingFrequency = 1
--   --    finishOnWait = False
--   --    config = def
--   --      { -- chainSeekHost = "127.0.0.1"
--   --        Apps.chainSeekSyncPort = 33584 -- 3715
--   --      , Apps.chainSeekCommandPort = 33582 -- 3720
--   --      , Apps.runtimePort = 33589 -- 3700
--   --      -- , Apps.runtimeHost = "127.0.0.1"
--   --      -- , timeoutSeconds = 900
--   --      -- , buildSeconds = 3
--   --      -- , confirmSeconds = 3
--   --      -- , retrySeconds = 10
--   --      -- , retryLimit = 5
--   --      }
--
--   --    run = Apps.Run.runClientWithConfig config $ streamAllContractSteps eventBackend pollingFrequency finishOnWait contractId contractChan
--
--   --    -- FIXME: Improve error reporting - mark channel as dead or something?
--   --    notifyErr (Right res) = pure res
--   --    notifyErr (Left ex) = do
--   --      let
--   --        msg = "Marlowe runtime communication thread failure..." <> displayException ex
--   --      logTraceMsg "runMarloweSyncClient" msg
--
--   --  void . liftIO . forkFinally run $ notifyErr
--   --  pure contractChan
--
-- runScriptTest scriptEnv scriptSt stScriptOperations =
--   do
--     let
--       -- We gonna make runtime an optional requirment for the runner
--       -- eventBackend = undefined
--       interpretLoop = for_ stScriptOperations \operation -> do
--         logSoMsg SoName operation ""
--         interpret operation
--
--     void $ catchError
--       (runReaderT (execStateT interpretLoop scriptSt) scriptEnv)
--       $ \e -> do
--         -- TODO: Clean up wallets and instances.
--         liftIO (print e)
--         liftIO (putStrLn "***** FAILED *****")
--         throwError (e :: CliError)
--     liftIO $ putStrLn "***** PASSED *****"
--
-- rewriteCurrencyRefs :: MonadIO m
--                   => MonadState (ScriptState lang era) m
--                   => MonadError CliError m
--                   => A.Value
--                   -> m A.Value
-- rewriteCurrencyRefs = A.rewriteBottomUp rewrite
--   where
--     rewrite = \case
--       obj@(A.Object (KeyMap.toAscList -> props)) -> do
--         case props of
--           [("currency_symbol", A.String "") , ("token_name", A.String "")] -> pure obj
--           [("currency_symbol", A.String currencyNickname) , ("token_name", tokenName)] -> do
--               let
--                 nickname = CurrencyNickname $ Text.unpack currencyNickname
--               Currency { ccCurrencySymbol=P.CurrencySymbol cs } <- findCurrency nickname
--               pure $ A.object
--                 [
--                   ("currency_symbol", A.toJSON cs)
--                 , ("token_name", tokenName)
--                 ]
--           _ -> pure obj
--       v -> do
--         pure v
--
-- rewritePartyRefs :: MonadIO m
--                  => MonadState (ScriptState lang era) m
--                  => MonadError CliError m
--                  => A.Value
--                  -> m A.Value
-- rewritePartyRefs = A.rewriteBottomUp rewrite
--   where
--     rewrite = \case
--       A.Object (KeyMap.toList -> [("address", A.String walletNickname)]) -> do
--         wallet <- findWallet (WalletNickname $ Text.unpack walletNickname)
--         (network, address) <- marloweAddressFromCardanoAddress $ waAddress wallet
--         pure $ A.toJSON (M.Address network address)
--       v -> do
--         pure v
--
-- decodeContractJSON :: MonadIO m
--                    => MonadState (ScriptState lang era) m
--                    => MonadError CliError m
--                    => A.Value
--                    -> m M.Contract
-- decodeContractJSON json = do
--   contractJSON <- rewritePartyRefs json
--   case A.fromJSON contractJSON of
--     A.Error err -> throwError . CliError $ "[decodeContractJSON] contract json (" <> Text.unpack (A.renderValue json) <> ") parsing error: " <> show err
--     A.Success contract -> pure contract
--
--
-- decodeInputJSON :: MonadIO m
--                 => MonadState (ScriptState lang era) m
--                 => MonadError CliError m
--                 => A.Value
--                 -> m M.Input
-- decodeInputJSON json = do
--   json' <- rewritePartyRefs json
--   json'' <- rewriteCurrencyRefs json'
--   case A.fromJSON json'' of
--     A.Error err -> throwError . CliError $ "[decodeInputJSON] contract input json (" <> Text.unpack (A.renderValue json'') <> ") parsing error: " <> show err
--     A.Success input -> pure input
--
--
-- lovelaceToPlutusValue :: C.Lovelace -> P.Value
-- lovelaceToPlutusValue (C.Lovelace v) = P.singleton P.adaSymbol P.adaToken v
--
--
-- foldMapFlipped :: Monoid b => Foldable f => f a -> (a -> b) -> b
-- foldMapFlipped = flip foldMap
--
-- foldMapMFlipped :: Monoid b => Monad m => Foldable f => f a -> (a -> m b) -> m b
-- foldMapMFlipped = flip foldMapM
--
-- anyFlipped :: [a] -> (a -> Bool) -> Bool
-- anyFlipped = flip any
--
>>>>>>> 11628a12d (WIP. Introduce runtime to the DSL. Ongoing split of the interpreters.)
