{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE NamedFieldPuns #-}

module Network.Oracle (
  Oracle (..),
  OracleEnv,
  makeOracle,
  oracles,
  readOracle,
  toOracleSymbol,
) where

import Data.Maybe (fromJust)
import Control.Exception (catch, IOException)
import Data.Text (Text)
import Data.Aeson (encode)
import Network.HTTP.Client (Manager)
import Network.Oracle.CoinGecko (Currency (..), CurrencyPair (..), coinGeckoEnv, fetchCurrencyPair)
import Network.Oracle.Sofr (fetchSofrBasisPoints, nyfrbEnv)
<<<<<<< HEAD
import Observe.Event.Dynamic (DynamicEventSelector (..))
=======
import Network.Oracle.Random (fetchRandom, randomEnv)
import Language.Marlowe.Oracle.Types (OracleRequest(..), choiceName')
import Language.Marlowe.Core.V1.Semantics.Types (Bound(..))
import Observe.Event.Dynamic (DynamicEventSelector(..))
>>>>>>> a613caaeb (PLT-5726 Added random oracle and provid bound and continuations to oracles.)
import Observe.Event.Explicit (EventBackend, addField, withEvent)
import Observe.Event.Syntax ((≔))
import Servant.Client (ClientEnv)
import Text.Read (readMaybe)
import System.Process (readProcess)

import qualified Data.ByteString.Lazy.Char8 as LBS8 (unpack)

<<<<<<< HEAD
data Oracle
  = SOFR
  | BTCETH
  | BTCEUR
  | BTCGBP
  | BTCJPY
  | BTCUSD
  | ADABTC
  | ADAETH
  | ADAEUR
  | ADAGBP
  | ADAJPY
  | ADAUSD
  | ETHBTC
  | ETHEUR
  | ETHGBP
  | ETHJPY
  | ETHUSD
=======

data Oracle = SOFR | RANDOM | BTCETH | BTCEUR | BTCGBP | BTCJPY | BTCUSD | ADABTC | ADAETH | ADAEUR | ADAGBP | ADAJPY | ADAUSD | ETHBTC | ETHEUR | ETHGBP | ETHJPY | ETHUSD
>>>>>>> a613caaeb (PLT-5726 Added random oracle and provid bound and continuations to oracles.)
  deriving (Bounded, Enum, Eq, Ord, Read, Show)

toOracleSymbol :: String -> Maybe Oracle
toOracleSymbol = readMaybe

oracles :: [Oracle]
oracles = [minBound .. maxBound]

pairs :: [(Oracle, (Currency, Currency))]
pairs =
  [ (BTCETH, (BTC, ETH))
  , (BTCEUR, (BTC, EUR))
  , (BTCGBP, (BTC, GBP))
  , (BTCJPY, (BTC, JPY))
  , (BTCUSD, (BTC, USD))
  , (ADABTC, (ADA, BTC))
  , (ADAETH, (ADA, ETH))
  , (ADAEUR, (ADA, EUR))
  , (ADAGBP, (ADA, GBP))
  , (ADAJPY, (ADA, JPY))
  , (ADAUSD, (ADA, USD))
  , (ETHBTC, (ETH, BTC))
  , (ETHEUR, (ETH, EUR))
  , (ETHGBP, (ETH, GBP))
  , (ETHJPY, (ETH, JPY))
  , (ETHUSD, (ETH, USD))
  ]

data OracleEnv = OracleEnv
  { nyfrb :: ClientEnv
  , coinGecko :: ClientEnv
  , random :: ClientEnv
  }

makeOracle
  :: Manager
  -> IO OracleEnv
makeOracle manager =
  OracleEnv
    <$> nyfrbEnv manager
    <*> coinGeckoEnv manager
    <*> randomEnv manager

readOracle
  :: EventBackend IO r DynamicEventSelector
  -> Either String OracleEnv
  -> OracleRequest
  -> IO (Either String Integer)
<<<<<<< HEAD
readOracle eventBackend OracleEnv{..} symbol =
  do
    withEvent eventBackend (DynamicEventSelector "Oracle") $
      \event ->
        do
          addField event $ ("symbol" :: Text) ≔ show symbol
          value <-
            case symbol of
              SOFR -> do
                addField event $ ("source" :: Text) ≔ ("NYFRB" :: String)
                addField event $ ("unit" :: Text) ≔ ("basis points" :: String)
                fetchSofrBasisPoints nyfrb
              _ -> do
                result <- uncurry (fetchCurrencyPair coinGecko) . fromJust $ symbol `lookup` pairs
                addField event $ ("source" :: Text) ≔ ("CoinGecko" :: String)
                addField event $ ("result" :: Text) ≔ show result
                addField event $ ("unit" :: Text) ≔ ("/ 100,000,000" :: String)
                pure $ rate <$> result
          addField event $
            either (("failure" :: Text) ≔) (("value" :: Text) ≔) value
          pure value
=======
readOracle eventBackend oracleEnv oracleRequest@OracleRequest{..} =
 do
  withEvent eventBackend (DynamicEventSelector "Oracle")
    $ \event ->
      do
        let
          symbol = choiceName' oracleRequest
        addField event $ ("symbol" :: Text) ≔ symbol
        value <-
          case (oracleEnv, toOracleSymbol symbol) of
            (Right OracleEnv{nyfrb}, Just SOFR) ->
              do
                addField event $ ("source" :: Text) ≔ ("NYFRB" :: String)
                addField event $ ("unit" :: Text) ≔ ("basis points" :: String)
                fetchSofrBasisPoints nyfrb
            (Right OracleEnv{random}, Just RANDOM) ->
              case bounds of
                [Bound min' max'] ->
                  do
                    addField event $ ("source" :: Text) ≔ ("Random.Org" :: String)
                    addField event $ ("min" :: Text) ≔ min'
                    addField event $ ("max" :: Text) ≔ max'
                    fetchRandom min' max' random
                _ -> pure . Left $ "Illegal multiple bounds: " <> show bounds <> "."
            (Right OracleEnv{coinGecko}, Just symbol') ->
              do
                result <- uncurry (fetchCurrencyPair coinGecko) . fromJust $ symbol' `lookup` pairs
                addField event $ ("source" :: Text) ≔ ("CoinGecko" :: String)
                addField event $ ("result":: Text)  ≔ show result
                addField event $ ("unit" :: Text) ≔ ("/ 100,000,000" :: String)
                pure $ rate <$> result
            (Right _, Nothing) -> pure . Left $ "Unknown oracle symbol: " <> symbol <> "."
            (Left command, _) ->
              (
                do
                  result <- readProcess command [] . LBS8.unpack $ encode oracleRequest
                  case readMaybe result of
                    Just result' -> pure $ pure result'
                    Nothing -> pure . Left $ "Illegal result: " <> result <> "."
              ) `catch` (\e -> pure . Left $ show (e :: IOException))
        addField event
          $ either (("failure":: Text)  ≔) (("value":: Text)  ≔) value
        pure value
>>>>>>> a613caaeb (PLT-5726 Added random oracle and provid bound and continuations to oracles.)
